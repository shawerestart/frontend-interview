## 前言
---
最近面试处处碰壁，面试机会也少，确实挺打击人的心态的。还出现了以学历本位出现的学历歧视链，没有学历你的技能都是虚无，国内的互联网环境真的是一言难尽，996，PUA，培训班卷互联网。
每个公司都有自己的风格，有的公司要求你技术栈丰富，有的公司只要你去当一颗螺丝钉，有的公司要你有能站在产品的角度思考问题，有的公司要你重复增删改查直到35岁被炒。
这个项目就是自己亲自打字纪录下来的面试过程，以加深记忆。

## 面试题总结
---
### 1. 请说一下HTTPS协议的工作原理?
    1. 客户端使用https url来访问服务器，会要求服务器建立ssl链接
    2. 服务器接收到请求后，会将网站的证书(有公钥)，发送给客户端
    3. 客户端和服务器协商ssl加密等级
    4. 客户端和服务器协商完加密等级后，两边建立[会话秘钥]， 通过公钥加密[会话秘钥]并传送给网站
    5. 服务器用自己的私钥解密出会话秘钥
    6. 服务器通过会话秘钥加密解密客户端和服务器之间的通信

### 2. TCP3次握手4次挥手?
    3次握手
        1. 第一次握手，建立连接，客户端发送syn包(syn = j)给服务器
        2. 服务器收到syn包后，发送ack=j+1的确认包和服务器syn包(syn = k)给客户端
        3. 客户端接收到ack和服务器的syn包后,发送syn=k+1包给服务器，连接建立完成
        
    4次挥手
        1. 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。

        2. 服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。
        3. 客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最 后的数据）。
        4. 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。
        5. 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
        6. 服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。

![四次挥手](/images/tcp_4times.png)


### 3. 从输入URL到页面加载全过程
    1. 输入URL后查询缓存，查询缓存的顺序为： 浏览器缓存-系统缓存-路由缓存-ISP缓存
        - 浏览器缓存
            浏览器会记录DNS一段时间，因此，只是第一个地方解析DNS请求；
        - 系统缓存
            如果在浏览器缓存中不包含这个记录，则会使系统调用操作系统， 获取操作系统的记录(保存最近的DNS查询缓存)；
        - 路由缓存
            如果上述两个步骤均不能成功获取DNS记录，继续搜索路由器缓存；
        ISP缓存：若上述均失败，继续向ISP搜索。
    2. DNS域名解析：浏览器向DNS服务器发起请求，解析该URL中的域名对应的IP地址。DNS服务器是基于UDP的，因此会用到UDP协议。


    3. 建立TCP连接：解析出IP地址后，根据IP地址和默认80端口，和服务器建立TCP连接


    4. 发起HTTP请求：浏览器发起读取文件的HTTP请求，，该请求报文作为TCP三次握手的第三次数据发送给服务器


    5. 服务器响应请求并返回结果：服务器对浏览器请求做出响应，并把对应的html文件发送给浏览器


    6. 关闭TCP连接：通过四次挥手释放TCP连接


    7. 浏览器渲染：客户端（浏览器）解析HTML内容并渲染出来

### 4. 浏览器渲染顺序
    DOM Tree -> CSS Tree -> render Tree (combine DOM Tree and CSS Tree) -> Layout -> Painting -> JS Engine run scripts


### 5.浏览器重绘与重排的区别？

    『重绘』不一定会出现『重排』，『重排』必然会出现『重绘』。

强制缓存
    强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程。当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是 Expires 和 Cache-Control，其中Cache-Control优先级比Expires高。
    强制缓存的情况主要有三种(暂不分析协商缓存过程)，如下：

    不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致）。
    存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存。
    存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果



协商缓存
    协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，同样，协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：Last-Modified / If-Modified-Since 和 Etag / If-None-Match，其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。协商缓存主要有以下两种情况：

    协商缓存生效，返回304
    协商缓存失效，返回200和请求结果结果

### 6.谈谈事件循环

    宏任务（Macrotask）大概如下
        setTimeout
        setInterval
        MessageChannel
        I/O 
        setImmediate（Node环境
        script（整体代码块）

    微任务（Microtask）大概如下：
        MutationObserver（浏览器环境）
        promise.[ then/catch/finally ]

    事件队列 process.nextTick（Node环境）
    微任务和宏任务是绑定的，每个宏任务在执行时，会创建自己的微任务队列。
    微任务的执行时长会影响到当前宏任务的时长。比如一个宏任务在执行过程中，产生了 100 个微任务，执行每个微任务的时间是 10 毫秒，那么执行这 100 个微任务的时间就是 1000 毫秒，也可以说这 100 个微任务让宏任务的执行时间延长了 1000 毫秒。所以-你在写代码的时候一定要注意控制微任务的执行时长。
    在一个宏任务中，分别创建一个用于回调的宏任务和微任务，无论什么情况下，微任务都早于宏任务执行。